{
  "stack ops": {
    "items": {
      "clear": "(... -->) clears everything off the stack.",
      "cleard": "(... a --> a) clears all but the top item from the stack.",
      "stackDepth": "(--> n) returns the size of the stack.",
      "aa": "(a --> a a) push the top item on stack again.",
      "aaa": "(a --> a a a) push the top item on stack two more times.",
      "ba": "(a b --> b a) swap top two items.",
      "bac": "(a b c --> b a c) reorder items on stack.",
      "cba": "(a b c --> c b a) reorder items on stack.",
      "bca": "(a b c --> b c a) reorder items on stack.",
      "cab": "(a b c --> c a b) reorder items on stack.",
      "bab": "(a b --> b a b) reorder items on stack.",
      "aba": "(a b --> a b a) reorder items on stack.",
      "aab": "(a b --> a a b) reorder items on stack.",
      "aabb": "(a b --> a a b b) reorder items on stack.",
      "abab": "(a b --> a b a b) reorder items on stack.",
      "nip": "(a b --> b) remove second item on stack.",
      "pop": "(a -->) remove top item on stack."
    }
  },
  "loops": {
    "items": {
      "do": "(list \\item[..] -->) applies the function to each item of a finite list. Useful for side effects like printing or file writing."
    }
  },
  "conditional ops": {
    "items": {
      "equals": "(a b --> bool) returns 1 if a and b are structurally equivalent. If the data structures are cyclic then this may never terminate.",
      "less": "(a b --> bool) returns 1 if a is less than b structurally. If the data structures are cyclic then this may never terminate.",
      "greater": "(a b --> bool) returns 1 if a is greater than b structurally. If the data structures are cyclic then this may never terminate.",
      "if": "(A B C --> ..) if A is true then apply B else apply C.",
      "not": "(A --> bool) returns 0 if A is true and 1 if A is false.",
      "try": "(A B --> ..) apply function A. if an exception is thrown, function B is applied.",
      "throw": "(a -->) throw an exception.",
      "protect": "(A B --> ..) apply function A. if an exception is thrown, function B is applied and the exception is rethrown. Otherwise function B is applied and control continues as normal."
    }
  },
  "form ops": {
    "items": {
      "has": "@kk (form key --> bool) return whether a form contains the key.",
      "keys": "@k (form --> keys) return an array of the keys of the form.",
      "values": "@k (form --> values) return an array of the values of the form.",
      "kv": "@k (form --> keys values) return two arrays of the keys and values of the form.",
      "local": "@k (form --> local) return the head of the prototype inheritance list.",
      "parent": "@k (form --> parent) return the tail of the prototype inheritance list.",
      "dot": "@ka (form key --> item) return the value for the key.",
      "pushWorkspace": "(-->) pushes a new outer scope onto the workspace. New bindings will be made in the new outer scope.",
      "popWorkspace": "(-->) pops a scope from the workspace. All bindings in the outer scope will be forgotten."
    }
  },
  "ref ops": {
    "items": {
      "get": "@k (r --> a) return the value store in a ref.",
      "set": "(a r -->) store the value a in the ref r.",
      "R": "(a --> r) create a new Ref with the inital value a",
      "ZR": "(z --> r) create a new ZRef with the inital value z. A ZRefs is a mutable reference to a real number.",
      "P": "(a --> out in) create a new stream plug pair with the inital value a",
      "ZP": "(a --> out in) create a new signal plug pair with the inital value a."
    }
  },
  "function ops": {
    "items": {
      "Y": "(funA --> funB) Y combinator. funB calls funA with the last argument being funB itself. Currently the only way to do recursion. ",
      "noeach": "(fun --> fun) sets a flag in the function so that it will pass through arguments with @ operators without mapping them.",
      "!": "(... f --> ...) apply the function to its arguments, observing @ arguments as appropriate.",
      "!e": "(form fun --> ...) for each argument in the function, find the same named fields in the form and push those values as arguments to the function.",
      "compile": "(string --> fun) compile the string and return a function."
    }
  },
  "printing ops": {
    "items": {
      "printLength": "(--> length) return the number of items printed for lists.",
      "printDepth": "(--> depth) return the number of levels of nesting printed for lists.",
      "setPrintLength": "(length --> ) set the number of items printed for lists.",
      "setPrintDepth": "(depth -->) set the number of levels of nesting printed for lists.",
      "pr": "(A -->) print the top item on the stack. (no space or carriage return is printed)",
      "prdebug": "(A -->) print debug version of the top item on the stack. (no space or carriage return is printed)",
      "cr": "(-->) print a carriage return.",
      "sp": "(-->) print a space character.",
      "tab": "(-->) print a tab.",
      "prstk": "(-->) print the stack.",
      "minfo": "(-->) print memory management info.",
      "listdump": "(list -->) prints information about a list."
    }
  },
  "string ops": {
    "items": {
      "str": "(x --> string) convert x to a string.",
      "debugstr": "(x --> string) convert x to a debug string.",
      "strcat": "@ak (list separator --> string) convert elements of list to a string with separator string between each.",
      "strlines": "(list --> string) convert elements of list to a newline separated string.",
      "glob": "@k (pattern --> paths) return a list of file path names that match."
    }
  },
  "sample rate ops": {
    "items": {
      "sr": "(--> sampleRate) returns the sample rate. samples per second. ",
      "nyq": "(--> sampleRate/2) returns the nyquist rate",
      "isr": "(--> 1/sampleRate) returns the inverse sample rate",
      "inyq": "(--> 2/sampleRate) returns the inverse nyquist rate.",
      "rps": "(--> 2pi/sampleRate) returns the radians per sample"
    }
  },
  "help ops": {
    "items": {
      "help": "(fun -->) prints help for a function.",
      "helpbifs": "(-->) prints help for all built in functions.",
      "helpudfs": "(-->) prints help for all user defined functions.",
      "helpall": "(-->) prints help for all built in and user defined functions.",
      "helpLine": "(string -->) add a line to the user defined function help."
    }
  },
  "thread ops": {
    "items": {
      "go": "(fun -->) launches the function in a new thread.",
      "sleep": "(seconds -->) sleeps the current thread for the time given."
    }
  },
  "misc": {
    "items": {
      "type": "(a --> symbol) return a symbol naming the type of the value a.",
      "trace": "(bool -->) turn tracing on/off in the interpreter."
    }
  },
  "text files": {
    "items": {
      "load": "(filename -->) compiles and executes a text file.",
      "prelude": "(-->) opens the prelude file in the default text editor.",
      "examples": "(-->) opens the examples file in the default text editor.",
      "logfile": "(-->) opens the log file in the default text editor.",
      "readme": "(-->) opens the README file in the default text editor."
    }
  },
  "unary math ops": {
    "items": {
      "isalnum": "(x --> z) return whether an ASCII value is alphanumeric.",
      "isalpha": "(x --> z) return whether an ASCII value is alphabetic.",
      "isblank": "(x --> z) return whether an ASCII value is a space or tab character.",
      "iscntrl": "(x --> z) return whether an ASCII value is a control character.",
      "isdigit": "(x --> z) return whether an ASCII value is a digit.",
      "isgraph": "(x --> z) return whether an ASCII value is a graphic character.",
      "islower": "(x --> z) return whether an ASCII value is lower case.",
      "isprint": "(x --> z) return whether an ASCII value is a printable character.",
      "ispunct": "(x --> z) return whether an ASCII value is a punctuation character.",
      "isspace": "(x --> z) return whether an ASCII value is a graphic character.",
      "isupper": "(x --> z) return whether an ASCII value is upper case.",
      "isxdigit": "(x --> z) return whether an ASCII value is a hexadecimal digit.",
      "isascii": "(x --> z) return whether a value is ASCII",
      "tolower": "(x --> z) convert an ASCII character value to lower case.",
      "toupper": "(x --> z) convert an ASCII character value to upper case.",
      "toascii": "(x --> z) convert a value to ASCII by stripping the upper bits.",
      "0<=": "(x --> z) less than or equal to zero.",
      "0>=": "(x --> z) greater than or equal to zero.",
      "0<": "(x --> z) less than zero.",
      "0>": "(x --> z) greater than zero.",
      "0=": "(x --> z) equal to zero.",
      "even?": "(x --> z) is even.",
      "odd?": "(x --> z) is odd.",
      "prime?": "(x --> z) is prime.",
      "int?": "(x --> z) is integer.",
      "isfinite": "(x --> z) is x a finite number.",
      "isinf": "(x --> z) is x an infinity.",
      "isnan": "(x --> z) is x not a number.",
      "isnormal": "(x --> z) is x a normalized number (as opposed to denormals).",
      "signbit": "(x --> z) sign bit of x.",
      "abs": "(x --> z) absolute value.",
      "sgn": "(x --> z) signum function. returns -1 when x < 0, 0 when x == 0, 1 when x > 0.",
      "~": "(x --> z) logical negation. returns 1 when x == 0, else returns 0.",
      "neg": "(x --> z) negative. -x",
      "sqrt": "(x --> z) square root.",
      "cbrt": "(x --> z) cube root.",
      "rsqrt": "(x --> z) reciprocal square root.",
      "sq": "(x --> z) square. x x *",
      "ssq": "(x --> z) signed square. x x abs *",
      "cb": "(x --> z) x cubed. x 3 ^",
      "^2": "(x --> z) x squared. x x *",
      "^3": "(x --> z) x cubed. x 3 ^",
      "^4": "(x --> z) x to the fourth power. x 4 ^",
      "^5": "(x --> z) x to the fifth power. x 5 ^",
      "^6": "(x --> z) x to the sixth power. x 6 ^",
      "^7": "(x --> z) x to the seventh power. x 7 ^",
      "^8": "(x --> z) x to the eighth power. x 8 ^",
      "^9": "(x --> z) x to the ninth power. x 9 ^",
      "recip": "(x --> z) reciprocal.",
      "1/": "(x --> z) reciprocal. 1 x /",
      "exp": "(x --> z) e to the x.",
      "exp2": "(x --> z) 2 to the x.",
      "exp10": "(x --> z) 10 to the x.",
      "e^": "(x --> z) e to the x.",
      "2^": "(x --> z) 2 to the x.",
      "10^": "(x --> z) 10 to the x.",
      "expm1": "(x --> z) computes exp(x-1) accurately even for very small values of x.",
      "log": "(x --> z) base e log of x.",
      "log2": "(x --> z) base 2 log of x.",
      "log10": "(x --> z) base 10 log of x.",
      "log1p": "(x --> z) computes the value of log(1+x) accurately even for very small values of x.",
      "logb": "(x --> z) x log2 floor",
      "frac": "(x --> z) fractional part.",
      "floor": "(x --> z) nearest integer <= x.",
      "ceil": "(x --> z) nearest integer >= x.",
      "rint": "(x --> z) nearest integer.",
      "erf": "(x --> z) the error function.",
      "erfc": "(x --> z) the complement of the error function.",
      "sinc": "(x --> z) sinc. x sin x /",
      "sin": "(x --> z) sine.",
      "cos": "(x --> z) cosine.",
      "sin1": "(x --> z) sine(x * 2pi).",
      "cos1": "(x --> z) cosine(x * 2pi).",
      "tan": "(x --> z) tangent.",
      "asin": "(x --> z) arcsine.",
      "acos": "(x --> z) arccosine.",
      "atan": "(x --> z) arctangent.",
      "sinh": "(x --> z) hyperbolic sine.",
      "cosh": "(x --> z) hyperbolic cosine.",
      "tanh": "(x --> z) hyperbolic tangent.",
      "asinh": "(x --> z) hyperbolic arcsine.",
      "acosh": "(x --> z) hyperbolic arccosine.",
      "atanh": "(x --> z) hyperbolic arctangent.",
      "J0": "(x --> z) zeroth Bessel function of the first kind evaluated at x.",
      "J1": "(x --> z) first Bessel function of the first kind evaluated at x.",
      "Y0": "(x --> z) zeroth Bessel function of the second kind evaluated at x.",
      "Y1": "(x --> z) first Bessel function of the second kind evaluated at x.",
      "tgamma": "(x --> z) the gamma function.",
      "lgamma": "(x --> z) natural logarithm of the absolute value of the gamma function.",
      "inc": "(x --> z) increment. x 1 +",
      "dec": "(x --> z) decrement. x 1 -",
      "half": "(x --> z) x .5 *",
      "twice": "(x --> z) x 2 *",
      "++": "(x --> z) increment. x 1 +",
      "--": "(x --> z) decrement. x 1 -",
      "/2": "(x --> z) half.",
      "*2": "(x --> z) twice.",
      "biuni": "(x --> z) convert bipolar to unipolar. .5 * .5 +",
      "unibi": "(x --> z) convert unipolar to bipolar. 2 * 1 -",
      "biunic": "(x --> z) convert bipolar to unipolar with clipping to range. -1 1 clip .5 * .5 +",
      "unibic": "(x --> z) convert unipolar to bipolar with clipping to range. 0 1 clip 2 * 1 -",
      "cmpl": "(x --> z) unipolar complement. 1 x -",
      "ampdb": "(x --> z) convert linear amplitude to decibels.",
      "dbamp": "(x --> z) convert decibels to linear amplitude.",
      "ohz": "(x --> z) convert octaves to Hertz. Octave 0.0 is middle C.",
      "hzo": "(x --> z) convert Hertz to octaves. Octave 0.0 is middle C.",
      "nnhz": "(x --> z) convert MIDI note numbers to Hertz. 60 is middle C.",
      "hznn": "(x --> z) convert Hertz to MIDI note numbers. 60 is middle C.",
      "centsratio": "(x --> z) convert an interval in cents to a ratio.",
      "ratiocents": "(x --> z) convert a ratio to an interval in cents.",
      "semiratio": "(x --> z) convert an interval in semitones to a ratio.",
      "ratiosemi": "(x --> z) a ratio to an interval in semitones.",
      "minsec": "(x --> z) convert from minutes to seconds. also for converting from bps to bpm",
      "secmin": "(x --> z) convert from seconds to minutes. also for converting from bpm to bps.",
      "bpmsec": "(x --> z) convert from beats per minute to a period in seconds(e.g. for delay times)",
      "degrad": "(x --> z) convert from degrees to radians.",
      "raddeg": "(x --> z) convert from radians to degrees.",
      "distort": "(x --> z) sigmoid wave distortion function. x/sqrt(1 + x^2)",
      "softclip": "(x --> z) sigmoid wave distortion function. returns x when abs(x) < .5, else returns (abs(x) - .25) / x",
      "sigm": "(x --> z) sigmoid wave distortion function. x/sqrt(1+x*x).",
      "rectWin": "(x --> z) rectangular window for x in the interval [0,1].",
      "triWin": "(x --> z) triangular window for x in the interval [0,1].",
      "bitriWin": "(x --> z) triangular window for x in the interval [-1,1]",
      "hanWin": "(x --> z) hanning window for x in the interval [0,1]",
      "sinWin": "(x --> z) sine window for x in the interval [0,1]",
      "ramp": "(x --> z) return 0 when x <= 0, return x when 0 < x < 1, return 1 when x > 1.",
      "scurve": "(x --> z) return 0 when x <= 0, return 3*x*x - 2*x*x*x when 0 < x < 1, return 1 when x > 1.",
      "zapgremlins": "(x --> z)"
    }
  },
  "binary math ops": {
    "items": {
      "op/": "(list --> z) reducing math operator.",
      "op\\": "(list --> z) scanning math operator.",
      "op^": "(list --> z) pairwise math operator.",
      "op/i": "(list init --> z) reducing math operator with initial value.",
      "op\\i": "(list init --> z) scanning math operator with initial value.",
      "op^i": "(list init --> z) pairwise math operator with initial value.",
      "+": "(x y --> z) addition.",
      "+>": "(x y --> z) addition. For lists, acts as if shorter list were extended with zeroes.",
      "-": "(x y --> z) subtraction.",
      "*": "(x y --> z) multiplication.",
      "/": "(x y --> z) real division.",
      "%": "(x y --> z) modulo.",
      "idiv": "(x y --> z) integer division.",
      "imod": "(x y --> z) integer modulo.",
      "remainder": "(x y --> z) remainder.",
      "<": "(x y --> z) less than.",
      "<=": "(x y --> z) less than or equal.",
      ">": "(x y --> z) greater than.",
      ">=": "(x y --> z) greater than or equal.",
      "==": "(x y --> z) equal.",
      "!=": "(x y --> z) not equal.",
      "cmp": "(x y --> z) returns -1 when x < y, returns 1 when x > y, returns 0 when x == y.",
      "copysign": "(x y --> z) copy the sign of y to the value of x.",
      "nextafter": "(x y --> z) return the next machine representable number from x in direction y.",
      "pow": "(x y --> z) x to the power y.",
      "^": "(x y --> z) x to the power y.",
      "atan2": "(x y --> z) arctangent of y/x.",
      "Jn": "(x y --> z) yth Bessel function of the first kind evaluated at x.",
      "Yn": "(x y --> z) yth Bessel function of the second kind evaluated at x.",
      "&": "(x y --> z) return the minimum of x and y. functions as logical AND.",
      "|": "(x y --> z) return the maximum of x and y. functions as logical OR.",
      "avg2": "(x y --> z) x y + .5 *",
      "dim": "(x y --> z) positive difference of x and y. x y - 0 |",
      "absdif": "(x y --> z) x y - abs",
      "hypot": "(x y --> z) x sq y sq + sqrt",
      "sumsq": "(x y --> z) x sq y sq +",
      "difsq": "(x y --> z) x sq y sq -",
      "sqsum": "(x y --> z) x y + sq",
      "sqdif": "(x y --> z) x y - sq",
      "thresh": "(x y --> z) returns 0 when x < y, else returns x.",
      "absthresh": "(x y --> z) returns 0 when |x| < y, else returns x.",
      "amclip": "(x y --> z) returns 0 when y <= 0, else returns x*y.",
      "scaleneg": "(x y --> z) returns x*y when x < 0, else returns x.",
      "ring1": "(x y --> z) x y * x +",
      "ring2": "(x y --> z) x y * x + y +",
      "ring3": "(x y --> z) x sq y *",
      "ring4": "(x y --> z) x y * x y - *",
      "gcd": "(x y --> z) greatest common divisor.",
      "lcm": "(x y --> z) least common multiple.",
      "clip0": "(x y --> z) clip x between 0 and y.",
      "wrap0": "(x y --> z) wrap x between 0 and y.",
      "fold0": "(x y --> z) fold x between 0 and y.",
      "clip2": "(x y --> z) clip x between -y and y.",
      "wrap2": "(x y --> z) wrap x between -y and y.",
      "fold2": "(x y --> z) fold x between -y and y.",
      "iwrap2": "(x y --> z) wrap integer x between -y and y.",
      "ifold2": "(x y --> z) fold integer x between -y and y.",
      "excess": "(x y --> z) return the excess after clipping. x x y clip2 -",
      "round": "(x y --> z) round x to nearest multiple of y.",
      "roundUp": "(x y --> z) round x to nearest multiple of y >= x.",
      "trunc": "(x y --> z) round x to nearest multiple of y <= x"
    }
  },
  "list conversion": {
    "items": {
      "V": "(signal --> stream) converts a signal or string to a stream.",
      "Z": "(series --> signal) converts a stream or string to a signal.",
      "L": "(anything --> stream) streams are returned as is. anything else is made into an infinite stream of itself.",
      "L1": "(anything --> stream) streams are returned as is. anything else is wrapped in a one item list.",
      "unspell": "(sequence --> string) converts a stream of numbers or a signal to a string."
    }
  },
  "basic list operations": {
    "items": {
      "size": "(seq --> num) Return the length of a sequence if it is finite. Returns inf if the sequence is of indefinite length (It may not actually be infinitely long).",
      "rank": "(a --> n) Return the rank of an object. Makes the assumption that lists at all depths are homogenous.",
      "shape": "(a --> [n..]) Return the shape of an object. Axes of indefinite length are represented by inf. Makes the assumption that lists at all depths are homogenous.",
      "finite": "(seq --> bool) Returns 1 if the sequence is finite, 0 if indefinite.",
      "empty": "(list --> bool) returns whether the list is empty.",
      "nonempty": "(list --> bool) returns whether the list is nonempty.",
      "head": "(list --> item) returns first item of list. fails if list is empty.",
      "tail": "(list --> list) returns the rest of the list after the first item. fails if list is empty.",
      "add": "(list item --> list) returns a new list with the item added to the end.",
      "cons": "(list item --> list) returns a new list with the item added to the front.",
      "uncons": "(list --> tail head) returns the tail and head of a list. fails if list is empty.",
      "pack": "(list --> list) returns a packed version of the list.",
      "packed": "(list --> bool) returns whether the list is packed."
    }
  },
  "list generation": {
    "items": {
      "ord": "(--> series) return an infinite series of integers ascending from 1.",
      "nat": "(--> series) return an infinite series of integers ascending from 0.",
      "invs": "(--> series) return an infinite series of reciprocals. equivalent to ord 1/",
      "negs": "(--> series) return an infinite series of integers descending from -1.",
      "evens": "(--> series) return an infinite series of ascending non-negative even integers.",
      "odds": "(--> series) return an infinite series of ascending non-negative odd integers.",
      "ints": "(--> series) return the infinite series [0 1 -1 2 -2 3 -3...]",
      "primes": "(--> series) returns a finite series of prime numbers up to 1000039.",
      "fib": "@kk (a b --> series) returns a fibonacci series starting with the two numbers given.",
      "ordz": "(--> signal) return an infinite signal of integers ascending from 1.",
      "natz": "(--> signal) return an infinite signal of integers ascending from 0.",
      "invz": "(--> signal) return an infinite signal of reciprocals. equivalent to ordz 1/",
      "negz": "(--> signal) return an infinite signal of integers descending from -1.",
      "evenz": "(--> signal) return an infinite signal of ascending non-negative even integers.",
      "oddz": "(--> signal) return an infinite signal of ascending non-negative odd integers.",
      "intz": "(--> signal) return the infinite signal [0 1 -1 2 -2 3 -3...]",
      "primez": "(--> signal) returns a finite signal of prime numbers up to 1000039.",
      "fibz": "@zz (a b --> signal) returns a fibonacci signal starting with the two numbers given.",
      "ninvs": "@k (n --> stream) return a finite stream of n reciprocals. equivalent to n 1 1 nby 1/",
      "ninvz": "@z (n --> signal) return a finite signal of n reciprocals. equivalent to n 1 1 nbyz 1/",
      "ever": "(value --> series) return an infinite stream of value.",
      "by": "@kk (start step --> series) return an infinite arithmetic series.",
      "nby": "@kkk (n start step --> series) return a finite arithmetic series.",
      "grow": "@kk (start step --> series) return an infinite geometric series.",
      "ngrow": "@kkk (start step --> series) return a finite geometric series.",
      "to": "@kk (a b --> series) return a finite series from a to b stepping by +1 if a < b, or -1 if a < b.",
      "everz": "@z (value --> signal) return an infinite signal of value.",
      "byz": "@zz (start step --> series) return an infinite arithmetic series as a signal.",
      "nbyz": "@zzz (start step --> series) return a finite arithmetic series as a signal.",
      "growz": "@zz (start step --> series) return an infinite geometric series as a signal.",
      "ngrowz": "@zzz (start step --> series) return a finite geometric series as a signal.",
      "toz": "@zz (a b --> series) return a finite signal from a to b stepping by +1 if a < b, or -1 if a < b.",
      "lindiv": "@kkk (n start end --> series) returns a series of n equal steps from start to end.",
      "expdiv": "@kkk (n start end --> series) returns a series of n exponentially spaced steps from start to end.",
      "lindivz": "@zzz (n start end --> series) returns a signal of n equal steps from start to end.",
      "expdivz": "@zzz (n start end --> series)  returns a signal of n exponentially spaced steps from start to end.",
      "lindiv1": "@kkk (n start end --> series) returns a series of n equal steps from start up to but not including end.",
      "expdiv1": "@kkk (n start end --> series) returns a series of n exponentially spaced steps from start up to but not including end.",
      "lindiv1z": "@zzz (n start end --> series) returns a signal of n equal steps from start up to but not including end.",
      "expdiv1z": "@zzz (n start end --> series)  returns a signal of n exponentially spaced steps from start up to but not including end.",
      "line": "@zzz (dur start end --> z) return a signal ramping linearly from start to end in dur seconds.",
      "xline": "@zzz (dur start end --> z) return a signal ramping exponentially from start to end in dur seconds.",
      "nord": "(n --> stream) finite stream of counting numbers. equivalent to: ord n N",
      "nordz": "(n --> stream) finite signal of counting numbers. equivalent to: ordz n N",
      "nnat": "(n --> stream) finite stream of counting numbers. equivalent to: nat n N",
      "nnatz": "(n --> stream) finite signal of counting numbers. equivalent to: natz n N",
      "/X": "(x n --> b) divide x by n and make a list repeating that value n times. Useful for tupletizing a duration."
    }
  },
  "list reduction operations": {
    "items": {
      "reduce": "@aak (list value fun --> value) applies fun to each item in list and the current value to get a new value. returns the ending value.",
      "reduce1": "@ak (list fun --> value) like reduce except that the initial value is the first item in the list.",
      "scan": "@aak (list value fun --> list) applies fun to each item in list and the current value to get a new value, which is added to the output list.",
      "scan1": "@ak (list fun --> list) like scan except that the initial value is the first item in the list.",
      "iter": "@ak (value fun --> list) returns an infinite list of repeated applications of fun to value.",
      "itern": "@akk (value fun n --> list) returns a list of n repeated applications of fun to value.",
      "chain": "@akk (value fun n --> list) returns the result of n repeated applications of fun to value."
    }
  },
  "list ordering operations": {
    "items": {
      "cyc": "(list --> list) makes a finite list become cyclic.",
      "ncyc": "@ak (n list --> list) concatenates n copies of a finite list.",
      "rcyc": "(ref --> list) gets a new list from ref each time list is exhausted.",
      "X": "@ak (value n --> stream) makes a list containing n copies of value. If value is a function, then the results of applying the function with an integer count argument is used as the contents of the output list.",
      "XZ": "@zz (value n --> signal) returns a signal with value repeated n times.",
      "mum": "@z (t --> signal) returns a signal of t seconds of silence.",
      "$": "(listA listB --> out) returns the concatenation of listA and listB.",
      "$z": "@zz (signalA signalB --> signal) returns the concatenation of signalA and signalB.",
      "$$": "(listA listB --> out) return the concatenation of the sublists of listA and listB. equivalent to (listA @ listB @ $)",
      "$/": "(list --> out) returns the concatenation of the sub-lists of the input list.",
      "flat": "(list --> list) flattens a list.",
      "flatten": "@ak (list n --> list) makes a list n levels flatter.",
      "keep": "@ak (list n --> list) returns a list of the first n items of the input list.",
      "T": "@zk (signal t --> signal) returns a signal of the first t seconds of the input signal.",
      "T>": "@zk (signal t --> signal) skips the first t seconds of the input signal.",
      "N>": "@ak (list n --> list) skips the first n items of the input list.",
      "N>>": "(list hops --> listOfLists) returns a list of tails of the input list. equivalent to (list (hops 0 | L 0 cons +\\) N>).",
      "T>>": "@za (signal hops --> listOfSignals) returns a list of tails of the input list. equivalent to (signal (hops 0 | L 0 cons +\\) T>).",
      "N": "@ak (list n --> list) returns a list of the first n items of the input list.",
      "NZ": "@zk (signal n --> signal) returns a signal of the first n items of the input signal. automaps over streams.",
      "skip": "@ak (list n --> list) skips the first n items of the input list.",
      "take": "@ak (list n --> list) returns a list of the first n items of the input list, or the last n items if n is negative and the list is finite.",
      "drop": "@ak (list n --> list) skips the first n items of the input list, or the last n items if n is negative and the list is finite.",
      "choff": "@akk (channel(s) c n --> out) takes a finite list of channels or a single signal and places it into an array of n channels beginning at offset c. Other channels are set to zero.",
      "tog": "(a b --> series) return a series alternating between a and b.",
      "togz": "@zz (a b --> signal) return a signal alternating between a and b.",
      "sel": "(a j --> out) select. a is a list of lists. out[i] is a[j][i]",
      "sell": "(a j --> out) lazy select. a is a list of lists. out[i] is the next value from a[j].",
      "?": "(a b --> out) the output list contains a[i] repeated b[i] times. If b is a list of booleans (1 or 0) then this functions as a filter.",
      "spread": "(a n --> out) inserts n[i] zeroes after a[i].",
      "spreadz": "@zz (a n --> signal) inserts n[i] zeroes after a[i]. automaps over stream inputs.",
      "change": "(a --> b) eliminates sequential duplicates in a signal or stream.",
      "changez": "@z (a --> b) eliminates sequential duplicates in a signal. automaps over streams.",
      "expand": "(a b --> out) when b is true, a value from a is written to out, when b is false, zero is written to out.",
      "expandz": "@zz (a b --> out) when b is true, a value from a is written to out, when b is false, zero is written to out. automaps over stream inputs.",
      "clump": "(a n --> out) groups elements from list a into sub-lists of size n.",
      "hang": "(a --> out) repeats the last value of a finite list indefinitely.",
      "hangz": "@z (a --> out) repeats the last value of a finite signal indefinitely. automaps over streams.",
      "histo": "@ak (a n --> out) makes a histogram of the finite stream a.",
      "histoz": "@zk (a n --> out) makes a histogram of the finite signal a. automaps over streams.",
      "keepWhile": "(a b --> out) return items from a while items from b are true.",
      "skipWhile": "(a b --> out) skip items from a while items from b are true.",
      "flop": "(a --> b) returns the transpose of the list of lists a. At least one of the dimensions must be finite.",
      "flops": "(a --> b) like flop, but signals are treated as scalars and not flopped.",
      "flop1": "(a --> b) like flop, but if list a is not a list of lists then it is wrapped in a list. compare: [[1 2 3][[4 5] 6 7]] @ flop $/ with: [[1 2 3][[4 5] 6 7]] @ flop1 $/",
      "lace": "(a --> b) returns the concatenation of the transpose of the list of lists a.",
      "merge": "@aak (a b fun --> c) merges two lists according to the function given. The function should work like <.",
      "mergec": "@aak (a b fun --> c) merges two lists without duplicates according to the function given. The function should work like cmp.",
      "perms": "(a --> b) returns a list of all permutations of the input list.",
      "permz": "@z (a --> b) returns a list of all permutations of the input signal. automaps over streams.",
      "permswr": "(a --> b) returns a list of all unique permutations of an input stream with repeated elements.",
      "permzwr": "@z (a --> b) returns a returns a list of all unique permutations of an input signal with repeated elements. automaps over streams.",
      "shortas": "(a b --> a') makes list a as short as list b.",
      "longas": "(a b --> a') makes list a as long as list b by repeating the last item.",
      "longas0": "(a b --> a') makes list a as long as list b by appending zeroes."
    }
  },
  "list ops": {
    "items": {
      "bub": "(a --> [a]) makes the top item on the stack into a one item list. i.e. puts a bubble around it.",
      "nbub": "(a n --> [[..[a]..]]) embeds the top item in N one item lists.",
      "2ple": "(a b --> [a b]) make a pair from the top two stack items.",
      "3ple": "(a b c --> [a b c]) make a triple from the top three stack items.",
      "4ple": "(a b c d --> [a b c d]) make a quadriple from the top four stack items.",
      "5ple": "(a b c d e --> [a b c d e]) make a quintuple from the top five stack items.",
      "6ple": "(a b c d e f --> [a b c d e f]) make a sextuple from the top six stack items.",
      "7ple": "(a b c d e f g --> [a b c d e f g]) make a septuple from the top seven stack items.",
      "8ple": "(a b c d e f g h --> [a b c d e f g h]) make an octuple from the top eight stack items.",
      "2ples": "@kk (a b --> [[a0 b0][a1 b1]..[aN bN]]) make a sequence of pairs from the sequences a and b.",
      "3ples": "@kkk (a b c --> [[a0 b0 c0][a1 b1 c1]..[aN bN cN]]) make a sequence of triples from the sequences a, b and c.",
      "4ples": "@kkkk (a b c d --> seq) make a sequence of quadruples from the sequences a, b, c and d.",
      "5ples": "@kkkkk (a b c d e --> seq) make a sequence of quintuples from the sequences a through e.",
      "6ples": "@kkkkkk (a b c d e f--> seq) make a sequence of sextuples from the sequences a through f.",
      "7ples": "@kkkkkkk (a b c d e f g--> seq) make a sequence of septuples from the sequences a through g.",
      "8ples": "@kkkkkkkk (a b c d e f g h --> seq) make a sequence of octuples from the sequences a through h.",
      "un2": "([a0 a1 .. aN-1] --> a0 a1) Push two items from a sequence onto the stack.",
      "un3": "([a0 a1 .. aN-1] --> a0 a1 a2) Push three items from a sequence onto the stack.",
      "un4": "([a0 a1 .. aN-1] --> a0 a1 a2 a3) Push four items from a sequence onto the stack.",
      "un5": "([a0 a1 .. aN-1] --> a0 a1 a2 a3 a4) Push five items from a sequence onto the stack.",
      "un6": "([a0 a1 .. aN-1] --> a0 a1 a2 .. a5) Push six items from a sequence onto the stack.",
      "un7": "([a0 a1 .. aN-1] --> a0 a1 a2 .. a6) Push seven items from a sequence onto the stack.",
      "un8": "([a0 a1 .. aN-1] --> a0 a1 a2 .. a7) Push eight items from a sequence onto the stack.",
      "reverse": "(a --> b) reverses a finite sequence.",
      "mirror0": "(a --> b) cyclic mirror of a sequence. [1 2 3 4] --> [1 2 3 4 3 2]",
      "mirror1": "(a --> b) odd mirror of a sequence. [1 2 3 4] --> [1 2 3 4 3 2 1]",
      "mirror2": "(a --> b) even mirror of a sequence. [1 2 3 4] --> [1 2 3 4 4 3 2 1]",
      "rot": "@ak (seq M --> seq') rotation of a sequence by M places. M > 0 moves right.",
      "shift": "@ak (seq M --> seq') shift of a sequence by M places. zeroes are shifted in to fill vacated positions.",
      "clipShift": "@ak (seq M --> seq') shift of a sequence by M places. the end value is copied in to fill vacated positions.",
      "foldShift": "@ak (seq M --> seq') shift of a sequence by M places. values from the cyclic mirrored sequence are copied in to fill vacated positions.",
      "muss": "(a --> b) puts a finite sequence into a random order.",
      "at": "(seq index(es) --> value(s)) looks up item(s) in sequence at index(es). out of range indexes return zero.",
      "wrapAt": "(seq index(es) --> value(s)) looks up item(s) in sequence at index(es). out of range indexes return the value at the end point.",
      "foldAt": "(seq index(es) --> value(s)) looks up item(s) in sequence at index(es). out of range indexes return the items from the cyclic sequence.",
      "clipAt": "(seq index(es) --> value(s)) looks up item(s) in sequence at index(es). out of range indexes return items from the cyclic mirrored sequence.",
      "degkey": "(degree scale --> converts scale degree(s) to keys, given a scale",
      "keydeg": "(key scale --> converts key(s) to scale degree(s), given a scale",
      "sort": "(in --> out) ascending order sort of the input list.",
      "sortf": "@ak (in fun --> out) sort of the input list using a compare function.",
      "sort>": "(in --> out) descending order sort of the input list.",
      "grade": "(in --> out) ascending order sorted indices of the input list.",
      "gradef": "@ak (in fun --> out) sorted indices of the input list using a compare function.",
      "grade>": "(in --> out) descending order sorted indices of the input list.",
      "0at": "(a --> a[0]) get the item at index 0",
      "1at": "(a --> a[1]) get the item at index 1",
      "2at": "(a --> a[2]) get the item at index 2",
      "3at": "(a --> a[3]) get the item at index 3",
      "4at": "(a --> a[4]) get the item at index 4",
      "5at": "(a --> a[5]) get the item at index 5",
      "6at": "(a --> a[6]) get the item at index 6",
      "7at": "(a --> a[7]) get the item at index 7",
      "8at": "(a --> a[8]) get the item at index 8",
      "9at": "(a --> a[9]) get the item at index 9"
    }
  },
  "event list operations": {
    "items": {
      "evmerge": "@aak (a b t --> c) merges event list 'b' with delay 't' with event list 'a' according to their delta times",
      "evdelay": "@ak (a t --> c) delay an event list by adding a preceeding rest of duration 't'",
      "evrest": "@aak (t --> c) returns a rest event for duration 't'."
    }
  },
  "dsp operations": {
    "items": {
      "kaiser": "@zz (n stopBandAttenuation --> out) returns a signal filled with a kaiser window with the given stop band attenuation.",
      "hanning": "@z (n --> out) returns a signal filled with a Hanning window.",
      "hamming": "@z (n --> out) returns a signal filled with a Hamming window.",
      "blackman": "@z (n --> out) returns a signal filled with a Blackman window.",
      "fft": "@zz (re im --> out) returns the complex FFT of two vectors (one real and one imaginary) which are a power of two length.",
      "ifft": "@zz (re im --> out) returns the complex IFFT of two vectors (one real and one imaginary) which are a power of two length.",
      "seg": "@zaa (in hops durs --> out) divide input signal in to a stream of signal segments of given duration stepping by hop time.",
      "wseg": "@zaz (in hops window --> out) divide input signal in to a stream of windowed signal segments of lengths equal to the window length, stepping by hop time."
    }
  },
  "audio I/O operations": {
    "items": {
      "play": "(channels -->) plays the audio to the hardware.",
      "record": "(channels filename -->) plays the audio to the hardware and records it to a file.",
      "stop": "(-->) stops any audio playing.",
      "sf>": "(filename -->) read channels from an audio file. not real time.",
      ">sf": "(channels filename -->) writes the audio to a file.",
      ">sfo": "(channels filename -->) writes the audio to a file and opens it in the default application.",
      "bench": "(channels -->) prints the amount of CPU required to compute a segment of audio. audio must be of finite duration.",
      "sgram": "(signal dBfloor filename -->) writes a spectrogram to a file and opens it."
    }
  },
  "random number generation": {
    "items": {
      "newseed": "(--> seed) make a new random seed.",
      "setseed": "(seed -->) set the random seed."
    }
  },
  "single random numbers": {
    "items": {
      "rand": "@kk (a b --> r) return a uniformly distributed random real value from a to b.",
      "coin": "@k (p --> r) return 1 with probability p, or 0 with probability (1-p).",
      "rand2": "@k (a --> r) return a uniformly distributed random real value from -a to +a.",
      "irand": "@kk (a b --> r) return a uniformly distributed random integer value from a to b.",
      "irand2": "@k (a --> r) return a uniformly distributed random real value from -a to +a.",
      "xrand": "@kk (a b --> r) return a exponentially distributed random real value from a to b.",
      "linrand": "@kk (a b --> r) return a linearly distributed random real value from a to b.",
      "ilinrand": "@kk (a b --> r) return a linearly distributed random integer value from a to b.",
      "wrand": "(w --> r) return a randomly chosen index from a list of probability weights. w should sum to one.",
      "pick": "(a --> r) return a randomly chosen element from the finite list a.",
      "wpick": "(a w --> r) return a randomly chosen element from the finite list a using probability weights from w. w must be the same length as a and should sum to one."
    }
  },
  "random streams": {
    "items": {
      "rands": "@kk (a b --> r) return a stream of uniformly distributed random real values from a to b.",
      "coins": "@k (p --> r) return a stream of 1 with probability p, or 0 with probability (1-p).",
      "eprands": "@kk (a b --> r) return a stream of uniformly distributed random integer values from a to b, excluding the previously returned value.",
      "rand2s": "@k (a --> r) return a stream of uniformly distributed random real values from -a to +a.",
      "irands": "@kk (a b --> r) return a stream of uniformly distributed random integer values from a to b.",
      "irand2s": "@k (a --> r) return a stream of uniformly distributed random real values from -a to +a.",
      "xrands": "@kk (a b --> r) return a stream of exponentially distributed random real values from a to b.",
      "linrands": "@kk (a b --> r) return a stream of linearly distributed random real values from a to b.",
      "ilinrands": "@kk (a b --> r) return a stream of linearly distributed random integer values from a to b.",
      "wrands": "(w --> r) return a stream of randomly chosen indices from a list of probability weights. w should sum to one.",
      "picks": "(a --> r) return a stream of randomly chosen elements from the finite list a.",
      "wpicks": "(a w --> r) return a stream of randomly chosen elements from the finite list a using probability weights from w. w must be the same length as a and should sum to one."
    }
  },
  "random signals": {
    "items": {
      "randz": "@zz (a b --> r) return a signal of uniformly distributed random real values from a to b.",
      "coinz": "@z (p --> r) return a signal of 1 with probability p, or 0 with probability (1-p).",
      "eprandz": "@zz (a b --> r) return a signal of uniformly distributed random integer values from a to b, excluding the previously returned value",
      "rand2z": "@z (a --> r) return a signal of uniformly distributed random real values from -a to +a.",
      "irandz": "@zz (a b --> r) return a signal of uniformly distributed random integer values from a to b.",
      "irand2z": "@z (a --> r) return a signal of uniformly distributed random real values from -a to +a.",
      "xrandz": "@zz (a b --> r) return a signal of exponentially distributed random real values from a to b.",
      "linrandz": "@zz (a b --> r) return a signal of linearly distributed random real values from a to b.",
      "ilinrandz": "@zz (a b --> r) return a signal of linearly distributed random integer values from a to b.",
      "wrandz": "@z (w --> r) return a signal of randomly chosen indices from a list of probability weights. w should sum to one.",
      "pickz": "@z (a --> r) return a signal of randomly chosen elements from the finite list a.",
      "wpickz": "@zz (a w --> r) return a signal of randomly chosen elements from the finite list a using probability weights from w. w must be the same length as a and should sum to one."
    }
  },
  "finite random streams": {
    "items": {
      "nrands": "@kkk (n a b --> r) return a stream of n uniformly distributed random real values from a to b.",
      "ncoins": "@kk (n p --> r) return a stream of n 1 with probability p, or 0 with probability (1-p).",
      "neprands": "@kkk (n a b --> r) return a stream of n uniformly distributed random integer values from a to b, excluding the previously returned value.",
      "nrand2s": "@kk (n a --> r) return a stream of n uniformly distributed random real values from -a to +a.",
      "nirands": "@kkk (n a b --> r) return a stream of n uniformly distributed random integer values from a to b.",
      "nirand2s": "@kk (n a --> r) return a stream of n uniformly distributed random real values from -a to +a.",
      "nxrands": "@kkk (n a b --> r) return a stream of n exponentially distributed random real values from a to b.",
      "nlinrands": "@kkk (n a b --> r) return a stream of n linearly distributed random real values from a to b.",
      "nilinrands": "@kkk (n a b --> r) return a stream of n linearly distributed random integer values from a to b.",
      "nwrands": "@ka (n w --> r) return a stream of n randomly chosen indices from a list of probability weights. w should sum to one.",
      "npicks": "@ka (n a --> r) return a stream of n randomly chosen elements from the finite list a.",
      "nwpicks": "@kaa (n a w --> r) return a stream of n randomly chosen elements from the finite list a using probability weights from w. w must be the same length as a and should sum to one."
    }
  },
  "finite random signals": {
    "items": {
      "nrandz": "@zzz (n a b --> r) return a signal of n uniformly distributed random real values from a to b.",
      "ncoinz": "@zz (n p --> r) return a signal of n 1 with probability p, or 0 with probability (1-p).",
      "neprandz": "@zzz (n a b --> r) return a signal of n uniformly distributed random integer values from a to b, excluding the previously returned value",
      "nrand2z": "@zz (n a --> r) return a signal of n uniformly distributed random real values from -a to +a.",
      "nirandz": "@zzz (n a b --> r) return a signal of n uniformly distributed random integer values from a to b.",
      "nirand2z": "@zz (n a --> r) return a signal of n uniformly distributed random real values from -a to +a.",
      "nxrandz": "@zzz (n a b --> r) return a signal of n exponentially distributed random real values from a to b.",
      "nlinrandz": "@zzz (n a b --> r) return a signal of n linearly distributed random real values from a to b.",
      "nilinrandz": "@zzz (n a b --> r) return a signal of n linearly distributed random integer values from a to b.",
      "nwrandz": "@zz (n w --> r) return a signal of n randomly chosen indices from a list of probability weights. w should sum to one.",
      "npickz": "@zz (n a --> r) return a signal of n randomly chosen elements from the finite signal a.",
      "nwpickz": "@zzz (n a w --> r) return a signal of n randomly chosen elements from the finite signal a using probability weights from w. w must be the same length as a and should sum to one."
    }
  },
  "noise unit generators": {
    "items": {
      "violet": "@z (amp --> z) violet noise",
      "blue": "@z (amp --> z) blue noise",
      "xorwhite": "@z (amp --> z) white noise",
      "xorwhite2": "@z (amp --> z) white noise",
      "rawhite": "@z (amp --> z) white noise based on Cessu's random access random numbers",
      "wangwhite": "@z (amp --> z) white noise based on Thomas Wang's integer hash",
      "citywhite": "@z (amp --> z) white noise based on a function from CityHash",
      "white": "@z (amp --> z) white noise",
      "pink": "@z (amp --> z) pink noise",
      "pink0": "@z (amp --> z) pink noise",
      "brown": "@z (amp --> z) brown noise",
      "gray": "@z (amp --> z) bit flip noise",
      "gray64": "@z (amp --> z) bit flip noise",
      "dust": "@zz (density amp --> z) a stream of impulses whose amplitude is random from 0 to a and whose average density is in impulses per second.",
      "dust2": "@zz (density amp --> z) a stream of impulses whose amplitude is random from -a to +a and whose average density is in impulses per second.",
      "velvet": "@zz (density amp --> z) a stream of impulses whose amplitude is randomly either -a or +a and whose average density is in impulses per second.",
      "toosh": "@zz (delay amp --> z) flanged noise. difference of two white noise sources with a delay.",
      "tooshp": "@zz (delay amp--> z) flanged noise. sum of two white noise sources with a delay. no null at delay == 0. ",
      "crackle": "@z (param --> z) a chaotic generator."
    }
  },
  "unit generators": {
    "items": {
      "*+": "@zzz (a b c --> out) multiply add. a b * c +"
    }
  },
  "wavetable generation": {
    "items": {
      "wavefill": "@aak (amps phases smooth -> wavetable) generates a set 1/3 octave wavetables for table lookup oscillators. sin(i*theta + phases[i])*amps[i]*pow(cos(pi*i/n), smooth). smoothing reduces Gibb's phenomenon. zero is no smoothing"
    }
  },
  "classic wave tables": {
    "items": {
      "parTbl": "parabolic wave table.",
      "triTbl": "triangle wave table.",
      "sqrTbl": "square wave table.",
      "sawTbl": "sawtooth wave table."
    }
  },
  "oscillator unit generators": {
    "items": {
      "osc": "@zzz (freq phase wavetable --> out) band limited wave table oscillator. wavetable is a table created with wavefill.",
      "oscp": "@zzzz (freq phase phaseOffset wavetable --> out) band limited wave table oscillator pair with phase offset.",
      "sosc": "@zz (freq1 freq2 wavetable --> out) band limited hard sync wave table oscillator. freq1 is the fundamental. freq2 is the slave oscil frequency.",
      "par": "@zz (freq phase --> out) band limited parabolic wave oscillator.",
      "tri": "@zz (freq phase --> out) band limited triangle wave oscillator.",
      "square": "@zz (freq phase --> out) band limited square wave oscillator.",
      "saw": "@zz (freq phase --> out) band limited sawtooth wave oscillator.",
      "pulse": "@zzz (freq phase duty --> out) band limited pulse wave oscillator.",
      "vsaw": "@zzz (freq phase duty --> out) band limited variable sawtooth oscillator.",
      "ssaw": "@zz (freq1 freq2 --> out) band limited hard sync sawtooth oscillator. freq1 is the fundamental. freq2 is the slave oscil frequency.",
      "blip": "@zzz (freq phase numharms --> out) band limited impulse oscillator.",
      "dsf1": "@zzzzz (freq carrierRatio modulatorRatio ampCoef numharms --> out) bandlimited partials with geometric series amplitudes. J.A.Moorer's equation 1",
      "dsf3": "@zzzzz (freq carrierRatio modulatorRatio ampCoef numharms --> out) two sided bandlimited partials with geometric series amplitudes. J.A.Moorer's equation 3",
      "lftri": "@zz (freq phase --> out) non band limited triangle wave oscillator.",
      "lfsaw": "@zz (freq phase --> out) non band limited sawtooth wave oscillator.",
      "lfpulse": "@zzz (freq phase duty --> out) non band limited unipolar pulse wave oscillator.",
      "lfpulseb": "@zzz (freq phase duty --> out) non band limited bipolar pulse wave oscillator.",
      "lfsquare": "@zz (freq phase --> out) non band limited square wave oscillator.",
      "impulse": "@zz (freq phase --> out) non band limited single sample impulse train oscillator.",
      "smoothsaw": "@zzz (freq phase nth --> out) smoothed sawtooth.",
      "smoothsawpwm": "@zzzz (freq phase nth duty --> out) smoothed sawtooth.",
      "vosim": "@zzz (freq phase nth --> out) vosim sim.",
      "sinosc": "@zz (freq phase --> out) sine wave oscillator.",
      "tsinosc": "@zz (freq iphase --> out) sine wave oscillator.",
      "sinoscfb": "@zzz (freq phase feedback --> out) sine wave oscillator with self feedback phase modulation",
      "sinoscm": "@zzzz (freq phase mul add --> out) sine wave oscillator with multiply and add.",
      "klang": "(freqs amps iphases --> out) a sine oscillator bank. freqs amps and iphases are arrays."
    }
  },
  "filter unit generators": {
    "items": {
      "lag": "@zz (in decayTime --> out) one pole lag filter. decayTime determines rate of convergence.",
      "lag2": "@zz (in decayTime --> out) cascade of two one pole lag filters. decayTime determines rate of convergence.",
      "lag3": "@zz (in decayTime --> out) cascade of three one pole lag filters. decayTime determines rate of convergence.",
      "lagud": "@zzz (in upDecayTime, downDecayTime --> out) one pole lag filter. up/down DecayTimes determines rate of convergence up/down.",
      "lagud2": "@zzz (in upDecayTime, downDecayTime --> out) cascade of two one pole lag filters. up/down DecayTimes determines rate of convergence up/down.",
      "lagud3": "@zzz (in upDecayTime, downDecayTime --> out) cascade of three one pole lag filters. up/down DecayTimes determines rate of convergence up/down.",
      "lpf1": "@zz (in freq --> out) low pass filter. 6 dB/oct.",
      "hpf1": "@zz (in freq --> out) high pass filter. 6 dB/oct.",
      "lpf": "@zz (in freq --> out) low pass filter. 12 dB/oct.",
      "hpf": "@zz (in freq --> out) high pass filter. 12 dB/oct.",
      "lpf2": "@zz (in freq --> out) low pass filter. 24 dB/oct.",
      "hpf2": "@zz (in freq --> out) high pass filter. 24 dB/oct.",
      "rlpf": "@zzz (in freq rq --> out) resonant low pass filter. 12 dB/oct slope. rq is 1/Q.",
      "rhpf": "@zzz (in freq rq --> out) resonant high pass filter. 12 dB/oct slope. rq is 1/Q.",
      "rlpf2": "@zzz (in freq rq --> out) resonant low pass filter. 24 dB/oct slope. rq is 1/Q.",
      "rhpf2": "@zzz (in freq rq --> out) resonant high pass filter. 24 dB/oct slope. rq is 1/Q.",
      "rlpfc": "@zzz (in freq rq --> out) resonant low pass filter with saturation. 12 dB/oct slope. rq is 1/Q.",
      "rhpfc": "@zzz (in freq rq --> out) resonant high pass filter with saturation. 12 dB/oct slope. rq is 1/Q.",
      "rlpf2c": "@zzz (in freq rq --> out) resonant low pass filter with saturation. 24 dB/oct slope. rq is 1/Q.",
      "rhpf2c": "@zzz (in freq rq --> out) resonant high pass filter with saturation. 24 dB/oct slope. rq is 1/Q.",
      "bpf": "@zzz (in freq bw --> out) band pass filter. bw is bandwidth in octaves.",
      "bsf": "@zzz (in freq bw --> out) band stop filter. bw is bandwidth in octaves.",
      "apf": "@zzz (in freq bw --> out) all pass filter. bw is bandwidth in octaves.",
      "peq": "@zzzz (in freq bw gain --> out) parametric equalization filter. bw is bandwidth in octaves.",
      "lsf": "@zzz (in freq gain --> out) low shelf filter.",
      "hsf": "@zzz (in freq gain --> out) high shelf filter.",
      "lsf1": "@zzz (in freq gain --> out) low shelf filter.",
      "resonz": "@zzz (in freq rq --> out) resonant filter.",
      "ringz": "@zzz (in freq ringTime --> out) resonant filter specified by a ring time in seconds.",
      "formlet": "@zzzz (in freq atkTime dcyTime --> out) a formant filter whose impulse response is a sine grain.",
      "klank": "@zaaa (in freqs amps ringTimes --> out) a bank of ringz filters. freqs amps and ringTimes are arrays.",
      "leakdc": "@zz (in coef --> out) leaks away energy at 0 Hz.",
      "leaky": "@zz (in coef --> out) leaky integrator.",
      "decay": "@zz (in decayTime --> out) outputs an exponential decay for impulses at the input.",
      "decay2": "@zzz (in atkTime dcyTime --> out) outputs an exponential attack and decay for impulses at the input.",
      "hilbert": "@z (in --> outA outB) returns two signals that are 90 degrees phase shifted from each other.",
      "ampf": "@zzz (in atkTime dcyTime --> out) amplitude follower."
    }
  },
  "delay unit generators": {
    "items": {
      "delayn": "@zzk (in delay maxdelay --> out) delay line with no interpolation.",
      "delayl": "@zzk (in delay maxdelay --> out) delay line with linear interpolation.",
      "delayc": "@zzk (in delay maxdelay --> out) delay line with cubic interpolation.",
      "flange": "@zzk (in delay maxdelay --> out) flanger with cubic interpolation. delay can be negative. latency is maxdelay.",
      "flangep": "@zzk (in delay maxdelay --> out) flanger with cubic interpolation. adds delayed signal instead of subtracts.",
      "combn": "@zzkz (in delay maxdelay decayTime --> out) comb delay filter with no interpolation.",
      "combl": "@zzkz (in delay maxdelay decayTime --> out) comb delay filter with linear interpolation.",
      "combc": "@zzkz (in delay maxdelay decayTime --> out) comb delay filter with cubic interpolation.",
      "lpcombc": "@zzkzz (in delay maxdelay decayTime lpfreq --> out) low pass comb delay filter with cubic interpolation.",
      "alpasn": "@zzkz (in delay maxdelay decayTime --> out) all pass delay filter with no interpolation.",
      "alpasl": "@zzkz (in delay maxdelay decayTime --> out) all pass delay filter with linear interpolation.",
      "alpasc": "@zzkz (in delay maxdelay decayTime --> out) all pass delay filter with cubic interpolation."
    }
  },
  "plugs": {
    "items": {}
  },
  "control rate subgraphs": {
    "items": {
      "kr": "(fun n --> out) evaluates fun with the current sample rate divided by n, then linearly upsamples all returned signals by n.",
      "krc": "(fun n --> out) evaluates fun with the current sample rate divided by n, then cubically upsamples all returned signals by n."
    }
  },
  "control function unit generators": {
    "items": {
      "imps": "@aaz (values durs rate --> out) single sample impulses.",
      "steps": "@aaz (values durs rate --> out) steps",
      "gates": "@aaaz (values durs holds rate --> out) gates",
      "lines": "@aaz (values durs rate --> out) lines",
      "xlines": "@aaz (values durs rate --> out) exponential lines",
      "cubics": "@az (values rate --> out) cubic splines",
      "curves": "@aaaz (values curvatures durs rate --> out) curves."
    }
  },
  "random control unit generators": {
    "items": {
      "lfnoise0": "@z (freq --> out) step noise source.",
      "lfnoise1": "@z (freq --> out) ramp noise source.",
      "lfnoise3": "@z (freq --> out) cubic spline noise source."
    }
  },
  "tempo unit generators": {
    "items": {
      "tempo": "@az ([bps dur bps dur ...] rate --> out) returns a signal of tempo vs time given a list of interleaved tempos (in beats per second) and durations (in beats).",
      "beats": "@z (tempo --> beats) integrates a tempo signal to produce a signal of the time in beats."
    }
  },
  "envelope unit generators": {
    "items": {
      "adsr": "@akkz ([attack decay sustain release] amp dur tempo --> envelope) an envelope generator.",
      "dadsr": "@akkz ([delay attack decay sustain release] amp dur tempo --> envelope) an envelope generator.",
      "dahdsr": "@akkz ([delay attack hold decay sustain release] amp dur tempo --> envelope) an envelope generator.",
      "endfade": "@zkkkk (in startupTime holdTime fadeTime threshold --> out) after startupTime has elapsed, fade out the sound when peak amplitude has dropped below threshold for more than the holdTime.",
      "fadeout": "@zkk (in sustainTime fadeTime --> out) fadeout after sustain.",
      "fadein": "@zk (in fadeTime --> out) fade in.",
      "parenv": "@k (dur --> out) parabolic envelope. 1-x^2 for x from -1 to 1",
      "quadenv": "@k (dur --> out) 4th order envelope. 1-x^4 for x from -1 to 1",
      "octenv": "@k (dur --> out) 8th order envelope. 1-x^8 for x from -1 to 1",
      "trienv": "@k (dur --> out) triangular envelope. 1-|x| for x from -1 to 1",
      "tri2env": "@k (dur --> out) triangle squared envelope. (1-|x|)^2 for x from -1 to 1",
      "trapezenv": "@k (dur --> out) trapezoidal envelope. (2 - |x-.5| - |x+.5|) for x from -1 to 1",
      "trapez2env": "@k (dur --> out) trapezoid squared envelope. (2 - |x-.5| - |x+.5|)^2 for x from -1 to 1",
      "cosenv": "@k (dur --> out) cosine envelope.",
      "hanenv": "@k (dur --> out) hanning envelope.",
      "han2env": "@k (dur --> out) hanning squared envelope.",
      "gaussenv": "@kk (dur width --> out) gaussian envelope. exp(x^2/(-2*width^2)) for x from -1 to 1",
      "tsig": "@zza (trig signal amp --> out) trigger a signal.",
      "tparenv": "@zaa (trig dur amp --> out) triggered parabolic envelope. 1-x^2 for x from -1 to 1",
      "tquadenv": "@zaa (trig dur amp --> out) triggered 4th order envelope. 1-x^4 for x from -1 to 1",
      "toctenv": "@zaa (trig dur amp --> out) triggered 8th order envelope. 1-x^8 for x from -1 to 1",
      "ttrienv": "@zaa (trig dur amp --> out) triggered triangular envelope. 1-|x| for x from -1 to 1",
      "ttri2env": "@zaa (trig dur amp --> out) triggered triangle squared envelope. (1-|x|)^2 for x from -1 to 1",
      "ttrapezenv": "@zaa (trig dur amp --> out) triggered trapezoidal envelope. (2 - |x-.5| - |x+.5|) for x from -1 to 1",
      "ttrapez2env": "@zaa (trig dur amp --> out) triggered trapezoid squared envelope. (2 - |x-.5| - |x+.5|)^2 for x from -1 to 1",
      "tcosenv": "@zaa (trig dur amp --> out) triggered cosine envelope.",
      "thanenv": "@zaa (trig dur amp --> out) triggered hanning envelope.",
      "than2env": "@zaa (trig dur amp --> out) triggered hanning squared envelope."
    }
  },
  "spawn unit generators": {
    "items": {
      "ola": "(sounds hops rate numChannels --> out) overlap add. This is the basic operator for polyphony. "
    }
  },
  "pause unit generator": {
    "items": {
      "pause": "@zz (in amp --> out) pauses the input when amp is <= 0, otherwise in is multiplied by amp."
    }
  },
  "panner unit generators": {
    "items": {
      "itd": "@zzk (in pan maxdelay --> out) interaural time delay.",
      "pan2": "@zz (in pos --> [left right]) stereo pan. pos 0 is center. pos -1 is full left, pos +1 is full right.",
      "rot2": "@zzz (left right pos --> [left right]) stereo rotation. pos 0 is no rotation, +/-1 is 180 degrees, -.5 is -90 degrees, +.5 is +90 degrees.",
      "bal2": "@zzz (left right pos --> [left right]) stereo balance control. pos 0 is center. pos -1 is full left, pos +1 is full right.",
      "fade2": "@zzz (left right pos --> out) cross fade between two inputs. pos 0 is equal mix. pos -1 is all left, pos +1 is all right."
    }
  },
  "trigger unit generators": {
    "items": {
      "tr": "@z (in --> out) transitions from nonpositive to positive become single sample impulses.",
      "ntr": "@z (in --> out) transitions from negative to nonnegative become single sample impulses.",
      "gate": "@z (in hold --> out) outputs 1 for hold seconds after each trigger, else outputs zero.",
      "sah": "@zz (in trigger --> out) sample and hold",
      "seq": "@az (in trigger --> out) pulls one value from the input for each trigger. output sustains at that level until the next trigger.",
      "iseq": "@az (in trigger --> out) pulls one value from the input for each trigger. outputs that value for one sample. outputs zero when there is no trigger.",
      "pdiv": "@zzz (in n istart --> out) pulse divider. outputs one impulse from the output for each n impulses in the input. istart is an offset. istart = 0 outputs a pulse on the first input pulse."
    }
  },
  "bounds unit generators": {
    "items": {
      "clip": "@zzz (in lo hi --> out) constrain the input to the bounds by clipping.",
      "wrap": "@zzz (in lo hi --> out) constrain the input to the bounds by wrapping.",
      "fold": "@zzz (in lo hi --> out) constrain the input to the bounds by folding at the edges.",
      "iwrap": "@zzz (in lo hi --> out) constrain the input to the bounds by wrapping. all inputs treated as integers.",
      "ifold": "@zzz (in lo hi --> out) constrain the input to the bounds by folding at the edges. all inputs treated as integers."
    }
  },
  "mouse control unit generators": {
    "items": {
      "mousex": "@zz (lo hi --> out) returns a signal of the X coordinate of the mouse mapped to the linear range lo to hi.",
      "mousey": "@zz (lo hi --> out) returns a signal of the Y coordinate of the mouse mapped to the linear range lo to hi.",
      "xmousex": "@zz (lo hi --> out) returns a signal of the X coordinate of the mouse mapped to the exponential range lo to hi.",
      "xmousey": "@zz (lo hi --> out) returns a signal of the Y coordinate of the mouse mapped to the exponential range lo to hi.",
      "mousex1": "@zz (lo hi --> out) returns the current value of the X coordinate of the mouse mapped to the linear range lo to hi.",
      "mousey1": "@zz (lo hi --> out) returns the current value of the Y coordinate of the mouse mapped to the linear range lo to hi.",
      "xmousex1": "@zz (lo hi --> out) returns the current value of the X coordinate of the mouse mapped to the exponential range lo to hi.",
      "xmousey1": "@zz (lo hi --> out) returns the current value of the Y coordinate of the mouse mapped to the exponential range lo to hi."
    }
  },
  "MIDI control": {
    "items": {
      "midiStart": "(-->) start up MIDI services",
      "midiRestart": "(-->) rescan MIDI services",
      "midiStop": "(-->) stop MIDI services",
      "midiList": "(-->) list MIDI endpoints",
      "midiConnectInput": "(sourceUID index -->) connect a MIDI source",
      "midiDisconnectInput": "(sourceUID index -->) disconnect a MIDI source",
      "midiDebug": "(onoff -->) turn on or off midi input monitoring"
    }
  },
  "MIDI instantaneous value": {
    "items": {
      "mctl1": "@zzzzz (srcIndex chan ctlnum lo hi --> out) value of midi controller mapped to the linear range [lo,hi].",
      "mpoly1": "@zzzzz (srcIndex chan key lo hi --> out) value of midi poly key pressure mapped to the linear range [lo,hi].",
      "mtouch1": "@zzzz (srcIndex chan lo hi --> out) value of midi channel pressure mapped to the linear range [lo,hi].",
      "mbend1": "@zzzz (srcIndex chan lo hi --> out) value of midi pitch bend mapped to the linear range [lo,hi].",
      "mprog1": "@zz (srcIndex chan --> out) value of midi channel program 0-127.",
      "mgate1": "@zzz (srcIndex chan key --> out) value of midi key state. 1 if key is down, 0 if key is up.",
      "mlastkey1": "@zz (srcIndex chan --> out) value of key of most recent midi note on.",
      "mlastvel1": "@zzzz (srcIndex chan lo hi --> out) value of velocity of most recent midi note on mapped to the linear range [lo,hi].",
      "xmctl1": "@zzzzz (srcIndex chan ctlnum lo hi --> out) value of midi controller mapped to the exponential range [lo,hi].",
      "xmpoly1": "@zzzzz (srcIndex chan key lo hi --> out) value of midi poly key pressure mapped to the exponential range [lo,hi].",
      "xmtouch1": "@zzzz (srcIndex chan lo hi --> out) value of midi channel pressure mapped to the exponential range [lo,hi].",
      "xmbend1": "@zzzz (srcIndex chan lo hi --> out) value of midi pitch bend mapped to the exponential range [lo,hi].",
      "xmlastvel1": "@zzzz (srcIndex chan lo hi --> out) value of velocity of most recent midi note on mapped to the exponential range [lo,hi]."
    }
  },
  "MIDI control signal": {
    "items": {
      "mctl": "@zzzzz (srcIndex chan ctlnum lo hi --> out) signal of midi controller mapped to the linear range [lo,hi].",
      "mpoly": "@zzzzz (srcIndex chan key lo hi --> out) signal of midi poly key pressure mapped to the linear range [lo,hi].",
      "mtouch": "@zzzz (srcIndex chan lo hi --> out) signal of midi channel pressure mapped to the linear range [lo,hi].",
      "mbend": "@zzzz (srcIndex chan lo hi --> out) signal of midi pitch bend mapped to the linear range [lo,hi].",
      "mlastkey": "@zz (srcIndex chan --> out) signal of key of most recent midi note on.",
      "mlastvel": "@zzzz (srcIndex chan lo hi --> out) signal of velocity of most recent midi note on mapped to the linear range [lo,hi].",
      "mprog": "@zz (srcIndex chan --> out) signal of midi channel program 0-127.",
      "mgate": "@zzz (srcIndex chan key --> out) signal of midi key state. 1 if key is down, 0 if key is up.",
      "xmctl": "@zzzzz (srcIndex chan ctlnum lo hi --> out) signal of midi controller mapped to the exponential range [lo,hi].",
      "xmpoly": "@zzzzz (srcIndex chan key lo hi --> out) signal of midi poly key pressure mapped to the exponential range [lo,hi].",
      "xmtouch": "@zzzz (srcIndex chan lo hi --> out) signal of midi channel pressure mapped to the exponential range [lo,hi].",
      "xmbend": "@zzzz (srcIndex chan lo hi --> out) signal of midi pitch bend mapped to the exponential range [lo,hi].",
      "xmlastvel": "@zzzz (srcIndex chan lo hi --> out) signal of velocity of most recent midi note on mapped to the exponential range [lo,hi]."
    }
  },
  "ZRef control signal": {
    "items": {
      "zctl": "@z (zref --> out) makes a smoothed control signal from a zref."
    }
  },
  "set operations": {
    "items": {
      "S": "(list --> set) removes all duplicates from a finite list.",
      "S|": "(listA listB --> set) returns the set union of the elements of lists A and B.",
      "S&": "(listA listB --> set) returns the set intersection of the elements of lists A and B.",
      "Sx": "(listA listB --> set) returns the set of the elements which occur in list A or B, but not both.",
      "S-": "(listA listB --> set) returns the set of the elements of listA which do not occur in listB.",
      "S=": "(listA listB --> set) returns 1 if the set of elements in listA is equal to the set of elements in listB.",
      "subset?": "(listA listB --> set) returns 1 if the set of elements of listA is a subset of the set of elements of listB. else 0.",
      "find": "(item(s) list --> set) returns index of item in finite list, or -1 if not in list.",
      "Shas": "(item(s) list --> set) returns 1 if finite list contains item(s), else 0."
    }
  },
  "printing": {
    "items": {
      "prall": "(list -->) print every item in a list on a separate line"
    }
  },
  "common counts": {
    "items": {
      "2X": "(a --> [a a]) a 2 X",
      "3X": "(a --> [a a a]) a 3 X",
      "4X": "(a --> [a a a a]) a 4 X",
      "5X": "(a --> [a .. a]) a 5 X",
      "6X": "(a --> [a .. a]) a 6 X",
      "7X": "(a --> [a .. a]) a 7 X",
      "8X": "(a --> [a .. a]) a 8 X",
      "9X": "(a --> [a .. a]) a 9 X",
      "2XZ": "(a --> #[a a]) a 2 XZ",
      "3XZ": "(a --> #[a a a]) a 3 XZ",
      "4XZ": "(a --> #[a a a a]) a 4 XZ",
      "5XZ": "(a --> #[a .. a]) a 5 XZ",
      "6XZ": "(a --> #[a .. a]) a 6 XZ",
      "7XZ": "(a --> #[a .. a]) a 7 XZ",
      "8XZ": "(a --> #[a .. a]) a 8 XZ",
      "9XZ": "(a --> #[a .. a]) a 9 XZ",
      "1N": "(a --> b) keeps the first item of the list a",
      "2N": "(a --> b) keeps the first 2 items of the list a",
      "3N": "(a --> b) keeps the first 3 items of the list a",
      "4N": "(a --> b) keeps the first 4 items of the list a",
      "5N": "(a --> b) keeps the first 5 items of the list a",
      "6N": "(a --> b) keeps the first 6 items of the list a",
      "7N": "(a --> b) keeps the first 7 items of the list a",
      "8N": "(a --> b) keeps the first 8 items of the list a",
      "9N": "(a --> b) keeps the first 9 items of the list a",
      "1N>": "(a --> b) skips the first item of the list a",
      "2N>": "(a --> b) skips the first 2 items of the list a",
      "3N>": "(a --> b) skips the first 3 items of the list a",
      "4N>": "(a --> b) skips the first 4 items of the list a",
      "5N>": "(a --> b) skips the first 5 items of the list a",
      "6N>": "(a --> b) skips the first 6 items of the list a",
      "7N>": "(a --> b) skips the first 7 items of the list a",
      "8N>": "(a --> b) skips the first 8 items of the list a",
      "9N>": "(a --> b) skips the first 9 items of the list a",
      "-1s": "(n --> [-1 ...]) returns a stream of n minus ones.",
      "0s": "(n --> [0 ...]) returns a stream of n zeroes.",
      "1s": "(n --> [1 ...]) returns a stream of n ones.",
      "2s": "(n --> [2 ...]) returns a stream of n twos.",
      "-1z": "(n --> #[-1 ...]) returns a signal of n minus ones.",
      "0z": "(n --> #[0 ...]) returns a signal of n zeroes.",
      "1z": "(n --> #[1 ...]) returns a signal of n ones.",
      "2z": "(n --> #[2 ...]) returns a signal of n twos."
    }
  },
  "ordinal accessing": {
    "items": {
      "1st": "(a --> a[0]) get the first item",
      "2nd": "(a --> a[1]) get the second item",
      "3rd": "(a --> a[2]) get the third item",
      "4th": "(a --> a[3]) get the fourth item",
      "5th": "(a --> a[4]) get the fifth item",
      "6th": "(a --> a[5]) get the sixth item",
      "7th": "(a --> a[6]) get the seventh item",
      "8th": "(a --> a[7]) get the eighth item",
      "9th": "(a --> a[8]) get the ninth item",
      "10th": "(a --> a[9]) get the tenth item",
      "last": "(a --> b) get the last value of a. or zero if empty.",
      "separate": "(a b --> c d) separates the list a such that list c contains all items of a for which b is true and list d contains all items of a for which b is false.",
      "span": "(a b --> c d) separates the list a such that list c contains all items of a for which b is true and list d contains all items of a for which b is false.",
      "runlengths": "(a --> b) returns a list of the number of consecutive occurrences of items in the input list.",
      "divmod": "(a b --> div mod) equivalent to ((a b idiv)(a b imod))"
    }
  },
  "each operators": {
    "items": {
      "each2": "(a b --> a @ b @) apply the each operator to two items on the stack",
      "each3": "(a b c --> a @ b @ c @) apply the each operator to three items on the stack",
      "each4": "(a b c d --> a @ b @ c @ d @) apply the each operator to four items on the stack",
      "cart2": "(a b --> a @1 b @2) apply the each operator for a cartesian product to two items on the stack",
      "cart3": "(a b c --> a @1 b @2 c @3) apply the each operator for a cartesian product to three items on the stack",
      "cart4": "(a b c d --> a @1 b @2 c @3 d @4) apply the each operator for a cartesian product to four items on the stack",
      "rcart2": "(a b --> a @2 b @1) apply the each operator for a reverse cartesian product to two items on the stack",
      "rcart3": "(a b c --> a @3 b @2 c @1) apply the each operator for a reverse cartesian product to three items on the stack",
      "rcart4": "(a b c d --> a @4 b @3 c @2 d @1) apply the each operator for a reverse cartesian product to four items on the stack"
    }
  },
  "range mapping": {
    "items": {
      "MS": "(L R --> M S) or (M S --> L R) stereo to mid-side conversion. this function is self inverse.",
      "-+": "(ctr dev --> lo hi) convert a center and deviation to lo and hi",
      "+-": "(a b --> hi lo) convert a center and deviation to hi and lo",
      "muldiv": "(a b --> a*b a/b) return both product and quotient",
      "divmul": "(a b --> a/b a*b) return both quotient and product",
      "cdv": "(lo hi --> ctr dev) convert lo and hi to center and deviation",
      "unilin": "(in lo hi --> out) map a unipolar input to the linear interval [lo, hi]",
      "unilinc": "(in lo hi --> out) map a unipolar input to the linear interval [lo, hi] clip input to bounds.",
      "uniexp": "(in lo hi --> out) map a unipolar input to the exponential interval [lo, hi]",
      "uniexpc": "(in lo hi --> out) map a unipolar input to the exponential interval [lo, hi] clip input to bounds.",
      "bilin": "(in lo hi --> out) map a bipolar input to the linear interval [lo, hi]",
      "bilinc": "(in lo hi --> out) map a bipolar input to the linear interval [lo, hi] clip input to bounds.",
      "biexp": "(in lo hi --> out) map a bipolar input to the exponential interval [lo, hi]",
      "biexpc": "(in lo hi --> out) map a bipolar input to the exponential interval [lo, hi] clip input to bounds.",
      "linlin": "(in a b c d --> out) map a linear interval [a,b] to a linear interval [c,d].",
      "linlinc": "(in a b c d --> out) map a linear interval [a,b] to a linear interval [c,d]. clip input to bounds.",
      "linexp": "(in a b c d --> out) map a linear interval [a,b] to an exponential interval [c,d].",
      "linexpc": "(in a b c d --> out) map a linear interval [a,b] to an exponential interval [c,d]. clip input to bounds.",
      "explin": "(in a b c d --> out) map an exponential interval [a,b] to a linear interval [c,d].",
      "explinc": "(in a b c d --> out) map an exponential interval [a,b] to a linear interval [c,d]. clip input to bounds.",
      "expexp": "(in a b c d --> out) map an exponential interval [a,b] to an exponential interval [c,d]",
      "expexpc": "(in a b c d --> out) map an exponential interval [a,b] to an exponential interval [c,d]. clip input to bounds."
    }
  },
  "range checking": {
    "items": {
      "inrange": "(in lo hi --> out) inclusive range check. return 1 if input is in the interval [lo,hi].",
      "exrange": "(in lo hi --> out) exclusive range check. return 1 if input is in the interval (lo,hi)."
    }
  },
  "borrowed from APL": {
    "items": {
      "reshape": "(list shape --> list) shape is a list of the sizes of each dimension of a matrix into which the input is reshaped.",
      "iota": "(shape --> list) returns a matrix of the positive integers in the given shape."
    }
  },
  "conditional mapping": {
    "items": {
      "mapif": "(list bools fun --> list) apply fun to those values for which the corresponding bool is true. Otherwise pass the value as is."
    }
  },
  "data flow operators": {
    "items": {
      "abf": "(a b f --> afx bfx) apply a function to top two items. equivalent to: a f b f",
      "abcf": "(a b c f --> af bf cf) apply a function to top three items. equivalent to: a f b f c f",
      "afg": "(a f g --> af ag) apply two functions to the top item. equivalent to: a f a g",
      "afgh": "(a f g h - af ag ah) apply three functions to the top item. equivalent to: a f a g a h",
      "abfg": "(a b f g --> af bg) interleaved application. equivalent to: a f b g",
      "abcfgh": "(a b c f g h --> af bg ch) interleaved application. equivalent to: a f b g c h",
      "abfg2": "(a b f g --> abf abg) interleaved application of binary operators. equivalent to: a b f a b g"
    }
  },
  "statistics": {
    "items": {
      "mean": "(a --> m) mean of list a.",
      "atf": "(a x --> out) return the linear interpolated value of list a at position x.",
      "median": "(a --> m) median of list a.",
      "variance": "(a --> v) variance of list a.",
      "deviation": "(a --> sd) standard deviation of list a.",
      "vmag": "(a --> |a|) vector magnitude of list a.",
      "fac": "(a --> b) factorial of a"
    }
  },
  "numbers": {
    "items": {
      "factors": "(x --> fs) returns a list of the factors of integer x.",
      "pfactors": "(x --> fs) returns a list of the prime factors of integer x.",
      "coprime": "(a b --> bool) test whether numbers  are coprime.",
      "coprimes": "(a --> bool) test whether numbers in list are coprime."
    }
  },
  "common random number generators": {
    "items": {}
  },
  "unipolar random number generators": {
    "items": {
      "urand": "(--> r) return a random number from 0 to 1.",
      "urands": "(--> r) return a stream of random numbers from 0 to 1.",
      "urandz": "(--> r) return a signal of random numbers from 0 to 1.",
      "nurands": "(n --> r) return a stream of n random numbers from 0 to 1.",
      "nurandz": "(n --> r) return a signal of n random numbers from 0 to 1."
    }
  },
  "bipolar random number generators": {
    "items": {
      "brand": "(--> r) return a random number from -1 to 1.",
      "brands": "(--> r) return a stream of random numbers from -1 to 1.",
      "brandz": "(--> r) return a signal of random numbers from -1 to 1.",
      "nbrands": "(n --> r) return a stream of n random numbers from -1 to 1.",
      "nbrandz": "(n --> r) return a signal of n random numbers from -1 to 1."
    }
  },
  "random walks": {
    "items": {
      "iwalk": "(step lo hi --> stream) integer random walk.",
      "iwalk2": "(step bounds --> stream) integer random walk. bipolar bounds.",
      "walk": "(step lo hi --> stream) random walk.",
      "walk2": "(step bounds --> stream) random walk. bipolar bounds.",
      "iwalkz": "(step lo hi --> signal) integer random walk.",
      "iwalk2z": "(step bounds --> signal) integer random walk. bipolar bounds.",
      "walkz": "(step lo hi --> signal) random walk.",
      "walk2z": "(step bounds --> signal) random walk. bipolar bounds."
    }
  },
  "composite ugens": {
    "items": {
      "oltx": "(sounds susTime xfadeTime density numChannels --> out) texture of overlapping sounds. OverlapTexture, adapted from SC2",
      "xftx": "(sounds susTime xfadeTime numChannels --> out) texture of crossfaded sounds. XFadeTexture, adapted from SC2",
      "randsign": "(in --> out) 50% chance of flipping the sign",
      "famp": "(freq root exponent --> out) frequency dependent amplitude compensation factor.",
      "lfo": "(freq phase lo hi --> out) sine wave lfo with linear range.",
      "xlfo": "(freq phase lo hi --> out) sine wave lfo with exponential range.",
      "splay": "(x --> out) evenly spread an array of mono sources across a stereo field.",
      "rsplay": "(x --> out) evenly spread an array of mono sources across a stereo field.",
      "splayd": "(x maxdelay --> out) evenly spread an array of mono sources across a stereo field using interaural time delay."
    }
  },
  "amplitude": {
    "items": {
      "rms": "(in --> out) calculate the rms amplitude. input must be finite.",
      "rmsdb": "(in --> out) calculate the rms amplitude in decibels. input must be finite."
    }
  },
  "uses of hilbert processor": {
    "items": {
      "freqShift": "(in shiftHz --> out) frequency shifter.",
      "ssb": "(in shiftHz --> out) single sideband modulator.",
      "bphaser": "(in lfoRate --> L R) barberpole phaser."
    }
  },
  "simple allpass reverbs": {
    "items": {
      "apverb4": "(in delayTime decayTime --> out) four stage stereo allpass with random delay times",
      "apverb6": "(in delayTime decayTime --> out) six stage stereo allpass with random delay times"
    }
  },
  "random sweeps and pans": {
    "items": {
      "rline": "(dur lo hi --> out) random line. both ends are uniformly random between lo and hi.",
      "xrline": "(dur lo hi --> out) exponentially random line. both ends are exponentially random between lo and hi.",
      "rxline": "(dur lo hi --> out) random exponential line. both ends are uniformly random between lo and hi.",
      "xrxline": "(dur lo hi --> out) exponentially random exponential line. both ends are exponentially random between lo and hi.",
      "rpanl2": "(in --> out) stereo pan at a fixed random position.",
      "rpan2": "(in --> out) stereo pan at a fixed random position.",
      "rbal2": "(a b --> out) stereo balance at a fixed random position.",
      "rrot2": "(in --> out) stereo rotation at a fixed random position.",
      "rsweeppan2": "(in dur --> out) stereo pan with a random sweep."
    }
  },
  "crossover filters": {
    "items": {
      "crossover": "(in freq --> high_band low_band) Linkwitz-Riley crossover filters. low_band + high_band yields a flat frequency response.",
      "crossover1": "(in freq --> high_band low_band) first order crossover filters. low_band + high_band yields a flat frequency response.",
      "midcrossover": "(in freq bw --> outer_band inner_band) middle crossover. outer_band + inner_band yields a flat frequency response.",
      "crossovermix": "(a b freq --> out) Linkwitz-Riley crossover mixer.",
      "crossover1mix": "(a b freq --> out) Linkwitz-Riley crossover mixer.",
      "midcrossovermix": "(a b freq bw --> out) Linkwitz-Riley crossover mixer."
    }
  },
  "delays with wet/dry mix": {
    "items": {
      "combnw": "(in delay maxdelay decay wet --> out) combn delay with wet/dry mix control.",
      "comblw": "(in delay maxdelay decay wet --> out) combl delay with wet/dry mix control.",
      "combcw": "(in delay maxdelay decay wet --> out) combc delay with wet/dry mix control."
    }
  },
  "complex <-> polar": {
    "items": {
      "xp": "(x y --> rho theta) complex to polar",
      "px": "(rho theta --> x y) polar to complex"
    }
  },
  "zero padding": {
    "items": {
      "padz": "(a n --> out) zero pad after. add n zeroes after list a.",
      "zpad": "(a n --> out) zero pad before. add n zeroes before list a.",
      "zpadz": "(a n --> out) zero pad before and after. add n zeroes before and after list a.",
      "nextPow2": "(a --> b) next power of two greater than or equal to a.",
      "padzto": "(a n --> out) add enough zeroes after list a to make the total size equal to n.",
      "dly": "(a t --> out) delay signal a by t seconds.",
      "N/2": "(a --> b) reduce the length of a stream or signal by half."
    }
  },
  "dsp functions": {
    "items": {
      "rfft": "(re -- > re im) real fft",
      "sincfill": "(n nz --> out) return a sinc (sin(x)/x) wave of size n containing nz zero crossings.",
      "kaisersinc": "(n nz stopBandAttenuation --> out) return a kaiser windowed sinc (win(x)*sin(x)/x) wave of size n containing nz zero crossings.",
      "sr/": "(samples --> seconds) convert from samples to seconds.",
      "sr*": "(seconds --> samples) convert from seconds to samples.",
      "duration": "(signal --> duration) return the duration of a finite signal."
    }
  },
  "normalization": {
    "items": {
      "normalize": "(in --> out) scale a list so that the peak absolute value is 1.",
      "conormalize": "(in --> out) normalize a list of lists with respect to the maximum absolute peak of all of them.",
      "conormalizeb": "(in --> out) normalize to y a list of lists with respect to the maximum absolute peak of all of them.",
      "sumto1": "(in --> out) scale a list so that its sum is 1.",
      "sumto": "(x y --> out) scale the list x so that its sum is y.",
      "absumto": "(x y --> out) scale the list x so that the sum of the absolute values is y.",
      "sumcut": "(x y --> out) cut the list x so that its sum is y. e.g.  nat pi sumcut ==> [0 1 2 .14159]",
      "qedo": "(x n --> q) take a ratio and quantize it to n edo.",
      "q12": "(x --> q) take a ratio and quantize it to 12 edo.",
      "q72": "(x --> q) take a ratio and quantize it to 72 edo.",
      "dv": "(x d --> out) add random deviations of amplitude d.",
      "ldv": "(x d --> out) add deviations of amplitude d in log2 space."
    }
  },
  "12 tone pitch set operations": {
    "items": {
      "ps-norm": "(x --> y) pitch set normalization.",
      "ps-inv": "(x --> y) pitch set mirror inversion.",
      "ps-rot": "(x --> y) return a normalized rotation of a pitch set x.",
      "ps-rots": "(x --> y) return a list of all normalized rotations of a pitch set x."
    }
  },
  "pitch operations": {
    "items": {
      "invert": "(x --> y) mirror inversion. [1 5 4 3] --> [5 1 2 3]",
      "replacehead": "(x v --> y) replace the head of list x with v.",
      "monotonic": "(x m --> y) adds multiples of m to elements of x in order to create a monotonic ascending sequence."
    }
  },
  "rhythm": {
    "items": {
      "rdiv": "(n p --> durs) randomly subdivide a total duration of n beats into p durations. n and p must be integers."
    }
  },
  "list co-length operations": {
    "items": {
      "shortest": "(x --> y) make all lists in list x as short as the shortest list",
      "longest": "(x --> y) make all lists in list x as long as the longest list via hang",
      "cycLongest": "(x --> y) make all lists in list x as long as the longest list via cyc",
      "cyclcm": "(x --> y) make all lists in list x as long as the least common multiple of their lengths.",
      "mircyc": "(x --> y) return a mirrored cycle. i.e. [1 2 3 4] --> [1 2 3 4 3 2 1 2 3 4 3 2...]",
      "mirLongest": "(x --> y) make all lists in list x as long as the longest list via mircyc"
    }
  },
  "synths": {
    "items": {
      "blah": "(pch dyn dur pan -> outs) saw->filter->amp synth voice",
      "lfblah": "(pch dyn dur pan -> outs) lfsaw->filter->amp synth voice",
      "saw-syn": "(freq db dur pan harms adsr --> out) sawtooth wave synth",
      "square-syn": "(freq db dur pan harms adsr --> out) square wave synth",
      "pulse-syn": "(freq duty db dur pan harms adsr --> out) variable width pulse wave synth",
      "osc-syn": "(freq db dur pan harms adsr wt --> out) wavetable oscillator synth",
      "saw-rsyn": "(freq db dur pan harms rq adsr --> out) sawtooth wave synth with resonant lpf",
      "square-rsyn": "(freq db dur pan harms rq adsr --> out) square wave synth with resonant lpf",
      "fm-syn": "(freq c m mx fb db dur pan adsr --> out) fm synth",
      "fm-syn3": "(freq c m mx fb db dur pan adsr --> out) 3 detuned carrier, 1 modulator fm"
    }
  },
  "events": {
    "items": {
      "ev-base": "a form containing the basic low level information for a music event.",
      "ev-dur": "(inEvents --> dur) return the duration of inEvents.",
      "ev-starts": "(inEvents --> startTimes) return a stream of start times for inEvents",
      "ev-end": "(inEvents --> endTime) return the maximum end time of inEvents.",
      "ev-reverse": "(inEvents --> outEvents) reverse an event list."
    }
  }
}